---
title: "Introduction to ipfitr"
author: "Ryan Timpe"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
  library(tidyverse)
  library(ipfitr)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

In market sizing and forecasting, we're often tasked with estimating large data tables with limited data or only tables of subtotals. For example, one might know the number of people employed in the a country by age range, as well as the gender breakdown of total employment without age. Using iterative proportion fitting with these two data series, one can estimate the number of people employed by age range AND gender.

[Iterative proportion fitting](https://en.wikipedia.org/wiki/Iterative_proportional_fitting) (IPF) has been used in market analysis for over 30 years. This package integrates the methodology, along with some more expansions of this technique, into the [tidyverse](https://github.com/tidyverse/tidyverse) in R.

The ipfitr package for R allows the user to input multiple high-level summary/aggregate data tables and create a single, full-dimension data table estimating individual cell values using iterative proportion fitting.

## Data: Three one-dimensional targets

To explore the function in the ipfitr package, we'll create three simple data frames to use as targets. Each target represents the total money spent at a fairground over the course of the weekend. `tar1` contains the money spent on each item at the fair; `tar2` contains the amount of money spent by each person; and `tar3` contains the daily totals. Note that the total of each of the three targets is equal, representing the total amount of money spent at the fair over the weekend.

```{r targets}
tar1 <- data.frame(
  item = c("Attractions", "Balloons", "Candy"),
  value = c(120, 150, 80),
  stringsAsFactors = F
)

tar2 <- data.frame(
  person = c("Abby", "Ben", "Charles", "Dexter"),
  value = c(70, 90, 110, 80),
  stringsAsFactors = F
)

tar3 <- data.frame(
  day = c("Friday", "Saturday", "Sunday"),
  value = c(100, 150, 100),
  stringsAsFactors = F
)

```

## Expanding data with ip_expand()

The ipfitr package can be used to estimate how much money each person spent on each item over each of the days. This takes our 10 data points (3+4+3) and creates 36 data points (3x4x3), while ensuring the 10 target data points remain true.

```{r ip_expand, message=FALSE, warning=FALSE}
tar_list <- list(tar1, tar2, tar3)

dat_1 <- ip_expand(tar_list)

head(dat_1)

```

`ip_expand()` is a wrapper function, performing two key IPF functions in a single step. First, the function takes all the targets (3 here) and creates a "seed" data frame that contains all combinations of the unique series in the targets along with a seed value of 1. From there, a fitting function takes over, scaling the seed value iteratively to each of the targets until all targets are met.

This is equivalent to running the two functions independently:
```{r ip_expand2, message=FALSE, warning=FALSE, eval=FALSE}
dat_1 <- ip_create_seed(tar_list) %>% ip_fit(tar_list)
```

## Seeding the IPF with ip_create_seed()

Initializing the seed values at 1 implies that one has no additional information about the relative distribution of the elements in the final output. In this example, the user has no additional information about the spending by each person on each item during each day of the weekend.

Alternatively, suppose you learn that Abby got her paycheck on Saturday, so most of her spending was on Saturday and Sunday rather than Friday. You can implement this vague piece of information using the seed. This information should impact spending on all items, so we can reduce all seed values for Abby on Friday by 50%.

```{r ip_create_seed, message=FALSE, warning=FALSE}
dat_2 <- ip_create_seed(tar_list) %>% 
  mutate(value = ifelse(person == "Abby" & day == "Friday", 0.5*value, value)) %>% 
  ip_fit(tar_list)

dat_1 %>% filter(person == "Abby",  day == "Friday")

dat_2 %>% filter(person == "Abby",  day == "Friday")

```

You'll notice that reducing Abby's seed on Friday by 50% does reduce the final spending estimates, but by less than 50%. The seed informs the intial starting point for Abby's Friday spending compared to her spending on other days, as well as Abby's spending on Friday relative to the other visitors' spending on Friday. From there, the scaling take over, ensuring all the targets are hit.

The seed value do not need to be based around 1 - any non-negative values will work. For example, you could use spending estimates of the fairground attendees from a previous visit as the seed for this visit.

Any seed values of 0 will remain 0 in the final IPF outputt.

## Masking the seed with ip_mask_seed()

## Implementing specific information with ip_fit()

